package applications.xor_gate;

import applications.Application;
import networks.NeuralNetwork;

/**
 * Implementation of Application, contains basic methods needed to train a
 * NeuralNetwork on a XOR Gate.
 * 
 * @author OdinhengeT
 * @date 14th November 2020
 * @see AppliedNetwork
 * @see Application
 * @see NeuralNetwork
 * @see XorGateDataGenerator
 */
public class XorGate extends Application {
	/**
	 * One of each possible input stored as a set (float)
	 */
	private static final float[][] INPUT_QD_F = { { 0.0f, 0.0f }, { 1.0f, 0.0f }, { 0.0f, 1.0f }, { 1.0f, 1.0f } };
	/**
	 * One of each possible input stored as a set (double)
	 */
	private static final double[][] INPUT_QD_D = { { 0.0, 0.0 }, { 1.0, 0.0 }, { 0.0, 1.0 }, { 1.0, 1.0 } };

	/**
	 * Creates a XorGate Application, isDataLoaded is set to true since the XorGate
	 * is small enough so its needless to load the data.
	 */
	public XorGate() {
		super.isDataLoaded = true;
	}

	/**
	 * loadF doesn't needs to be called, an does nothing but remind the user of this
	 * if called
	 */
	public void loadF() {
		System.out.println("The XOR application doesn't require loading.");
	}

	/**
	 * loadD doesn't needs to be called, an does nothing but remind the user of this
	 * if called
	 */
	public void loadD() {
		System.out.println("The XOR application doesn't require loading.");
	}

	/**
	 * Returns nbrInputs sets of trainingdata (float), generated by
	 * XorGateDataGenerator, first index is 0 for input and 1 for target
	 */
	public float[][][] getTrainingDataF(int nbrInputs) {
		float[][][] TrainingData = new float[2][1][1];
		TrainingData[0] = XorGateDataGenerator.generateInputF(nbrInputs);
		TrainingData[1] = XorGateDataGenerator.generateTargetF(TrainingData[0]);
		return TrainingData;
	}

	/**
	 * Returns nbrInputs sets of trainingdata (double), generated by
	 * XorGateDataGenerator, first index is 0 for input and 1 for target
	 */
	public double[][][] getTrainingDataD(int nbrInputs) {
		double[][][] TrainingData = new double[2][1][1];
		TrainingData[0] = XorGateDataGenerator.generateInputD(nbrInputs);
		TrainingData[1] = XorGateDataGenerator.generateTargetD(TrainingData[0]);
		return TrainingData;
	}

	/**
	 * Returns the entire set of evaluationdata (INPUT_QD_F + corresponding target,
	 * float) first index is 0 for input and 1 for target
	 */
	public float[][][] getEvaluationDataF() {
		float[][][] EvaluationData = new float[2][1][1];
		EvaluationData[0] = INPUT_QD_F;
		EvaluationData[1] = XorGateDataGenerator.generateTargetF(INPUT_QD_F);
		return EvaluationData;
	}

	/**
	 * Returns the entire set of evaluationdata (INPUT_QD_D + corresponding target,
	 * double) first index is 0 for input and 1 for target
	 */
	public double[][][] getEvaluationDataD() {
		double[][][] EvaluationData = new double[2][1][1];
		EvaluationData[0] = INPUT_QD_D;
		EvaluationData[1] = XorGateDataGenerator.generateTargetD(INPUT_QD_D);
		return EvaluationData;
	}

	/**
	 * Tests a NeuralNetwork (float) using the Evaluation data and returns a String
	 * containing the results of the diagnostic.
	 * 
	 * @param network the NeuralNetwork to run the diagnostic on
	 * @return a String containing the results of the diagnostic
	 */
	public String runDiagnosticF(NeuralNetwork network) {
		StringBuilder sb = new StringBuilder("==Diagnostic==" + System.lineSeparator());
		for (int i = 0; i < INPUT_QD_F.length; i++) {
			float result = network.run(INPUT_QD_F[i])[0];
			float[][] target = XorGateDataGenerator.generateTargetF(INPUT_QD_F);
			float error = (result - target[i][0]) * (result - target[i][0]) / 2;
			sb.append("  Input: " + INPUT_QD_F[i][0] + " & " + INPUT_QD_F[i][1] + " -> " + result + "  (Error: " + error
					+ ")" + System.lineSeparator());
		}
		return sb.toString();
	}

	/**
	 * Tests a NeuralNetwork (double) using the Evaluation data and returns a String
	 * containing the results of the diagnostic.
	 * 
	 * @param network the NeuralNetwork to run the diagnostic on
	 * @return a String containing the results of the diagnostic
	 */
	public String runDiagnosticD(NeuralNetwork network) {
		StringBuilder sb = new StringBuilder("==Diagnostic==" + System.lineSeparator());
		for (int i = 0; i < INPUT_QD_D.length; i++) {
			double result = network.run(INPUT_QD_D[i])[0];
			double[][] target = XorGateDataGenerator.generateTargetD(INPUT_QD_D);
			double error = (result - target[i][0]) * (result - target[i][0]) / 2;
			sb.append("  Input: " + INPUT_QD_D[i][0] + " & " + INPUT_QD_D[i][1] + " -> " + result + "  (Error: " + error
					+ ")" + System.lineSeparator());
		}
		return sb.toString();
	}

	/**
	 * Runs the regualr diagnostic (float), since it isn't very time consuming
	 * 
	 * @param network the NeuralNetwork to run the diagnostic on
	 * @return a String containing the results of the diagnostic
	 */
	public String runQuickDiagnosticF(NeuralNetwork network) {
		return this.runDiagnosticF(network);
	}

	/**
	 * Runs the regualr diagnostic (double), since it isn't very time consuming
	 * 
	 * @param network the NeuralNetwork to run the diagnostic on
	 * @return a String containing the results of the diagnostic
	 */
	public String runQuickDiagnosticD(NeuralNetwork network) {
		return this.runDiagnosticD(network);
	}

}
